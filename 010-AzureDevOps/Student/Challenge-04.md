# Challenge 04 - Azure Pipelines: Continuous Integration

[< Previous Challenge](./Challenge-03.md) - **[Home](../README.md)** - [Next Challenge >](./Challenge-05.md)

## Introduction

Great! Now that we have some infrastructure and some code, let's build it. In DevOps we automate this process using something called Continuous Integration. Take a moment to review the article below to gain a better understanding of what CI is. 

1. [What is Continuous Integration?](https://docs.microsoft.com/en-us/azure/devops/learn/what-is-continuous-integration)

## Description

In Azure DevOps we use Azure Pipelines to automate our build process. For our application the build process will not only compile our .NET Core application, it should test it, and package it into a Docker Container and publish the container to Azure Container Registry.

- Create another build pipeline like you did in Challenge 3 and name it `CI Build`
- Enable continuous integration on your build pipeline ([hint](https://learn.microsoft.com/en-us/azure/devops/pipelines/customize-pipeline?view=azure-devops))
- Leverage the pipeline assistant and add 3 .NET Core tasks to restore, build, and test the application.
   - There are the 4 major steps to building a .NET Core application, however we will only be using 3 since we will be containerizing the application. ([Hint](https://docs.microsoft.com/en-us/azure/devops/pipelines/languages/dotnet-core?view=azure-devops&tabs=designer)).
      1. First we call the `restore` command, this will get all the dependencies that our .NET core application needs to compile
      2. Next we call the `build` command, this will actually compile our code
      3. Next we call the `test` command, this will execute all our unit tests 


## Success Criteria

1. Your build should complete without any errors.
1. Review the test results generated by your build. 
   **HINT:** Look in the logs from your build to find where the test run was published. 
1. Verify that any changes to your application should trigger a build.

